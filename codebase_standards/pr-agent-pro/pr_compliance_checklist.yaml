pr_compliances:
  - title: "Compliance 7: Distributed System Tracing"
    is_blocker: true
    event: "Microservices and distributed system interactions"
    success_criteria: "End-to-end request tracing with correlation of actions across multiple services and comprehensive distributed context preservation"
    failure_criteria: "Loss of request context between services or inability to track request flow"
    code_example: |
      def verify_distributed_tracing(trace_context):
          required_keys = ['trace_id', 'parent_span_id', 'service_name']
          return all(key in trace_context for key in required_keys)

      def process_distributed_request(request):
          trace_context = {
              'trace_id': generate_trace_id(),
              'parent_span_id': get_current_span_id(),
              'service_name': 'user-service'
          }
          
          try:
              if verify_distributed_tracing(trace_context):
                  logger.info("Distributed request processing", extra=trace_context)
              
              result = forward_request_to_next_service(request, trace_context)
              return result
          except Exception as e:
              logger.error("Distributed request failed", extra={
                  'trace_context': trace_context,
                  'error': str(e)
              })
              raise

  - title: "Compliance 10: Cross-Repository Security and Information Isolation"
    is_blocker: true
    event: "Reading compliance files from global settings repositories, local repositories, and wikis across different projects with varying access permissions"
    success_criteria: "Compliance checks from one repository cannot expose sensitive information to unauthorized users in other repositories. Proper isolation between different organizations' compliance rules when using shared global settings"
    failure_criteria: "Information leakage between repositories, ability to access compliance rules from restricted repositories, or exposure of sensitive compliance criteria to unauthorized users"
    code_example: |
      def test_cross_repository_isolation():
          org_a_compliance = create_sensitive_compliance("org_a/settings")
          org_b_pr = create_pr("org_b/project")
          
          with mock_user("org_b_developer"):
              results = process_pr_with_compliance(org_b_pr)
              assert "org_a" not in str(results)
              assert not has_leaked_sensitive_rules(results, org_a_compliance)
              
          forked_repo = fork_repository("org_a/project", "external/fork")
          assert get_compliance_for_repo(forked_repo) != org_a_compliance

  - title: "Compliance 11: Production Scale Performance and Resource Management"
    is_blocker: true
    event: "Processing PRs in large enterprise environments with hundreds of compliance rules across multiple hierarchical configuration files while handling concurrent PR submissions"
    success_criteria: "PR processing completes within SLA (30 seconds) for 95th percentile, no memory leaks, graceful degradation under load, proper caching of compliance rules"
    failure_criteria: "PR processing timeouts, service outages during peak hours, cascading failures when global settings repository is slow/unavailable"
    code_example: |
      def test_production_scale_performance():
          env = setup_production_env(repos=1000, rules=500, concurrent_prs=50)
          baseline = measure_pr_processing(env, compliance_enabled=False)
          metrics = measure_pr_processing(env, compliance_enabled=True)
          
          assert metrics.p95_latency < 30000  # 30 seconds
          assert metrics.avg_latency / baseline.avg_latency < 2.0
          assert metrics.peak_memory_mb < 4096 and metrics.file_handles_leaked == 0
          
          simulate_global_repo_outage(env)
          assert measure_pr_processing(env).success_rate > 0.95
