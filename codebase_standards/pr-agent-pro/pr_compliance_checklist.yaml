pr_compliances:
  - title: "Compliance 7: Distributed System Tracing"
    is_blocker: true
    event: "Microservices and distributed system interactions"
    success_criteria: "End-to-end request tracing with correlation of actions across multiple services and comprehensive distributed context preservation"
    failure_criteria: "Loss of request context between services or inability to track request flow"
    code_example: |
      def verify_distributed_tracing(trace_context):
          required_keys = ['trace_id', 'parent_span_id', 'service_name']
          return all(key in trace_context for key in required_keys)

      def process_distributed_request(request):
          trace_context = {
              'trace_id': generate_trace_id(),
              'parent_span_id': get_current_span_id(),
              'service_name': 'user-service'
          }
          
          try:
              if verify_distributed_tracing(trace_context):
                  logger.info("Distributed request processing", extra=trace_context)
              
              result = forward_request_to_next_service(request, trace_context)
              return result
          except Exception as e:
              logger.error("Distributed request failed", extra={
                  'trace_context': trace_context,
                  'error': str(e)
              })
              raise


  - title: "Compliance 10: Hierarchical File Structure Verification"
    is_blocker: false
    event: "File system operations involving nested directory structures and path traversal"
    success_criteria: "Correct navigation through directory hierarchy, proper parent-child relationships maintained, and accurate path resolution without directory traversal vulnerabilities"
    failure_criteria: "Broken symbolic links, incorrect relative path resolution, or unauthorized access to parent directories"
    code_example: |
      from pathlib import Path
      
      def verify_hierarchy(root_path, structure):
          root = Path(root_path)
          for rel_path, props in structure.items():
              path = root / rel_path
              if not path.exists() or (props['type'] == 'dir') != path.is_dir():
                  return False
              if not path.resolve().is_relative_to(root.resolve()):
                  return False  # Path traversal detected
          return True
